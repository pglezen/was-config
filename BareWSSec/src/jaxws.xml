<?xml version="1.0" encoding="UTF-8"?>

<info>
  <title>Bare JAX-WS Web Services</title>
</info>

<section xml:id="sec.jaxws.clients">
  <info>
    <title>JAX-WS Clients</title>
  </info>
  
<para>
<emphasis role="bold">J</emphasis>ava 
<emphasis role="bold">A</emphasis>PI for 
<emphasis role="bold">X</emphasis>ML - 
<emphasis role="bold">W</emphasis>eb 
<emphasis role="bold">S</emphasis>ervices 
(JAX-WS) is a specification that addresses
Java web services development.  For web service clients, this amounts to
generating Java client service stubs and XML bindings for use in invoking
the web service.  <xref linkend="fig.jaxws.client.overview"/> illustrates how
these components fit together.  The green and yellow components
are generated from the WSDL.  The green is the service stub.  Its objects
make the remote call to the service provider.  The yellow represents
the XML-type-to-Java-type bindings (or simply XML bindings).  The XML
bindings are actually addressed by a separate specification called
<emphasis role="bold">J</emphasis>ava
<emphasis role="bold">A</emphasis>PI for
<emphasis role="bold">X</emphasis>ML
<emphasis role="bold">B</emphasis>indings
(JAXB) that is referenced by JAX-WS.  This is part of what makes JAX-WS
so much more powerful than its predecessor,
<emphasis role="bold">J</emphasis>ava 
<emphasis role="bold">A</emphasis>PI for 
<emphasis role="bold">X</emphasis>ML - 
<emphasis role="bold">R</emphasis>emote 
<emphasis role="bold">P</emphasis>rocedure
<emphasis role="bold">C</emphasis>all
(JAX-RPC).

</para>
<figure xml:id="fig.jaxws.client.overview">
  <title>JAX-WS Overview</title>
  <mediaobject>
    <imageobject condition="web">
      <imagedata fileref="images/jaxwsOverview.jpg" width="70%"/>
    </imageobject>
    <imageobject condition="print">
      <imagedata fileref="images/jaxwsOverview.jpg" width="5in"/>
    </imageobject>
  </mediaobject>
</figure>
<para>
Another recent improvement is the inclusion of the JAX-WS runtime in the
Java 6 SE (standard edition).  One no longer needs to reference special
"thin client" libraries to make web service clients run.  The generated
bindings run directly against a Java 6 or later runtime.  And not only
are the runtime classes available in the JRE, the 
<firstterm>wsimport</firstterm> utility, responsible for generating
the bindings from the WSDL, is
part of the JDK on any platform.  No special IDEs or tools are needed.
</para>
<para>
The XML bindings are Java classes that map to the XML schema types defined
in the WSDL.  (One says that a Java type is bound to the XML schema type.)
These types play the role of parameters for the service invocation.  The
invocation functions themselves are methods on the service stub objects.
The bindings objects are passed as parameters to the service objects.
</para>
<para>
The generated service and binding objects tie into the JAX-WS runtime.
This may be part of the JDK as in the diagram above.  Or it may be implemented
by a vendor such as Apache CXF or IBM WebSphere Application Server.  In any
case, it is responsible for 
</para>
<itemizedlist>
  <listitem>marshaling the data structures into a serialized XML stream, and</listitem>
  <listitem>implementing the network protocol to transport the XML stream
     to the server.</listitem>
</itemizedlist>
<para>
Finally, the client code is the consumer of the service.  It issues the request
to the service stub and does whatever it requires with the result.
</para>

<para>
Web service clients may be <firstterm>managed</firstterm> or 
<firstterm>unmanaged</firstterm>.  Managed clients are typically associated with
an application server.  The client is managed in the sense that aspects of its
configuration are controllable through the administrative capabilities of the
application server.  References to the service stub objects are usually 
retrieved from JNDI.

Unmanaged clients, also known as <firstterm>thin clients</firstterm>, do not rely
on any underlying application server structure for configuration.  Their service
client proxy objects are directly instantiated. Their configuration is usually
done by setting properties on the service stub instances.  There is nothing wrong
with running a thin client inside an application server.  It simply won't benefit
from enterprise manageability features.
</para>

<section xml:id="sec.jaxws.clients.thin">
<info>
  <title>Thin Clients</title>
</info>

</section>
<para>
A thin client is one that does not expect the presense of any application
server infrastructure.  That's not to say a thin client can't run within
an application server container.  It simply doesn't depend on the container
for resources or initialization.
</para>
<para>
Generating a thin client is easy and requires nothing more than a valid WSDL
and JDK 6.  The command for generating the JAX-WS bindings is
<emphasis role="bold">wsimport</emphasis>.  It should be in your command
line path so long as your JDK is.  To verify its version and presence in
your path, query its version.
</para>
<screen>$ wsimport -version
JAX-WS RI 2.1.6 in JDK 6
$
</screen>
<para>
We'll use the WSDL listed in <xref linkend="sec.listings.ccQuery.wsdl"/>.
It's a standalone WSDL file with a single operation that queries
information about a credit card account.  Let's start with the following
invocation of wsimport.
<screen>thinclient$ wsimport -d bin -s src -p org.acme.cc.jaxws ccQuery.wsdl
parsing WSDL...
generating code...
compiling code...
thinclient$
</screen>
The options have the following meanings.
<itemizedlist>
<listitem><option>-d</option> directory into which the compiled class files are placed</listitem>
<listitem><option>-s</option> directory into which the source code is generated</listitem>
<listitem><option>-p</option> package into which the source code is generated</listitem>
</itemizedlist>
If you run this command without first creating the <filename class="directory">bin</filename> 
and <filename class="directory">src</filename> directories, the command will give an error.
Otherwise you get the following generated bindings classes.

<screen>thinclient/src/org/acme/cc/jaxws$ ls -l
total 64
-rw-r--r--  1 pglezen  staff  1073 Jun 16 13:42 CCPortType.java
-rw-r--r--  1 pglezen  staff  2341 Jun 16 13:42 CCService.java
-rw-r--r--  1 pglezen  staff  1363 Jun 16 13:42 ObjectFactory.java
-rw-r--r--  1 pglezen  staff  1813 Jun 16 13:42 QueryFault.java
-rw-r--r--  1 pglezen  staff  1053 Jun 16 13:42 QueryFaultMsg.java
-rw-r--r--  1 pglezen  staff  2061 Jun 16 13:42 QueryRequest.java
-rw-r--r--  1 pglezen  staff  3727 Jun 16 13:42 QueryResponse.java
-rw-r--r--  1 pglezen  staff   108 Jun 16 13:42 package-info.java
thinclient/src/org/acme/cc/jaxws$ 
</screen>

The problem with this generation of bindings concerns the
<classname>CCService</classname> class.  It needs to find a copy of the WSDL and
without any additional arguments to <command>wsimport</command>, it uses the
fully-qualified path name to the from which the bindings were generated.

<programlisting>URL baseUrl;
baseUrl = org.acme.cc.jaxws.CCService.class.getResource(".");
url = new URL(baseUrl, "file:/Users/pglezen/thinclient/ccQuery.wsdl");
</programlisting>

Clearly we don't want code referencing an absolute path on a developer's
workstation.  We provide information to <command>wsimport</command> via
the <option>-wsdllocation</option>.  From the code snippet above, 
one can see that the base
of the URL begins with the package directory of the class itself.
The WSDL will be found if we add it to the directory holding
<filename>CCService.java</filename>.

<screen>thinclient$ wsimport -d bin -s src -p org.acme.cc.jaxws -wsdllocation ccQuery.wsdl ccQuery.wsdl
</screen>

This results in the following snippet in <filename>CCService.java</filename>.

<programlisting>URL baseUrl;
baseUrl = org.acme.cc.jaxws.CCService.class.getResource(".");
url = new URL(baseUrl, "ccQuery.wsdl");
</programlisting>

</para>


</section>
