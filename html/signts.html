<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Bare Timestamp Signatures with WS-Security</title><link href="main.css" type="text/css" rel="stylesheet"><meta content="DocBook XSL Stylesheets V1.77.1" name="generator"><meta name="description" content="This document is a member of the Bare Series of WAS topics distributed in both stand-alone and in collection form. The latest renderings and source are available on GitHub at ."><style type="text/css">
body { background-image: url('images/draft.png');
       background-repeat: no-repeat;
       background-position: top left;
       /* The following properties make the watermark "fixed" on the page. */
       /* I think that's just a bit too distracting for the reader... */
       /* background-attachment: fixed; */
       /* background-position: center center; */
     }</style></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h1 class="title"><a name="N10001"></a>Bare Timestamp Signatures with WS-Security</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Paul</span> <span class="surname">Glezen</span></h3><div class="affiliation"><span class="jobtitle">IT Specialist<br></span><span class="orgname">IBM<br></span> <span class="orgdiv">Software Services for WebSphere<br></span></div></div></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
        This document is a member of the Bare Series of WAS topics
        distributed in both stand-alone and in collection form.  The
        latest renderings and source are available on GitHub at
        <a class="link" href="http://pglezen.github.io/was-config" target="_top">http://pglezen.github.io/was-config</a>.
      </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec.chap.concepts">1. Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#sec.concepts.whatandhow">1.1. What versus How</a></span></dt><dt><span class="section"><a href="#sec.concepts.protandauth">1.2. Protection versus Authentication</a></span></dt><dt><span class="section"><a href="#sec.concepts.callbacks">1.3. Callback Handlers</a></span></dt><dt><span class="section"><a href="#sec.concepts.mustunderstand">1.4. Must Understand</a></span></dt><dt><span class="section"><a href="#sec.concepts.apps">1.5. Application Code Requirements</a></span></dt></dl></dd><dt><span class="section"><a href="#sec.chap.body">2. Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#sec.signts.keystores">2.1. Key Stores</a></span></dt><dt><span class="section"><a href="#sec.signts.policyset">2.2. The Policy Set</a></span></dt><dt><span class="section"><a href="#sec.signts.clientbindings">2.3. Client Policy Set Bindings</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.chap.concepts"></a>1.&nbsp;Concepts</h2></div></div></div><p>
WS-Policy is a very general framework for describing &ldquo;non-functional&rdquo; 
requirements for web services. WS-Policy applies to many aspects
of web services such as
addressing, reliability, notifications, and most commonly, security.
The power of this concept lies in the potential to apply these
policies to applications without requiring changes to the application
code. WS-Policy addresses a wide variety of requirements in a vendor 
neutral way. This has obvious benefits; but also leads to its commonly
cited drawback: its complexity and abstraction levels often discourage 
its adoption.
</p><p>
Since this document only addresses WS-Security, it often uses the terms 
WS-Policy and WS-Security interchangeably.
</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.concepts.whatandhow"></a>1.1.&nbsp;What versus How</h3></div></div></div><p>
  WS-Security documents, in order to be general enough to apply in a 
  platform-neutral way, are restricted to 
  <span class="emphasis"><em>what</em></span> is to be done. Examples of &ldquo;what&rdquo; include 
  &ldquo;encrypt this field&rdquo; or &ldquo;add a time stamp and sign it.&rdquo; But when it
  comes to implementing these mandates, there is still the question of 
  <span class="emphasis"><em>how</em></span>.
  The most common examples of "how" are &ldquo;how is an encryption key to be 
  procured&rdquo; or &ldquo;how is a certificate verified to be trustworthy&rdquo; or "how 
  is a certificate to be specified in a SOAP payload". In 
  WebSphere Application Server (<acronym class="acronym">WAS</acronym>), 
  this separation of concerns is implemented with 
  policy sets and policy set bindings. 
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.concepts.protandauth"></a>1.2.&nbsp;Protection versus Authentication</h3></div></div></div><p>
  The WS-Security configuration panels often distinguish between 
  protection tokens and authentication tokens. 
  In this context, protection refers to protecting the message from 
  eavesdropping and/or corruption (whether accidental or malicious). 
  Eavesdropping is addressed by encryption.
  Message corruption is addressed by signatures. 
  In this document these tokens are asymmetric X.509 binary security tokens.
  </p><p>
  Authentication tokens contain identity information. This identity 
  information may be encrypted and/or signed. It conveys to the provider 
  the identity on behalf of whom the request is executing.
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.concepts.callbacks"></a>1.3.&nbsp;Callback Handlers</h3></div></div></div><p>
  The WAS security runtime uses a framework to apply the same processing 
  pattern to similar scenarios. But while the high-level processing is the
  same, details about the input can vary widely. A common example is the 
  authentication process. One can authenticate via a user ID and password, 
  a SAML assertion, an LTPA token, an SSL certificate, or others. Each of 
  these types of authentication have a callback handler class associated 
  with it. When specifying which authentication to use, the callback handler 
  class is specified for processing and the callback class is populated with 
  the input. Each callback handler expects input in the form of its associated 
  callback.
  </p><p>
  This concept appears often in WS-Security configuration panels. 
  When confronted with a callback handler configuration, 
  it's just a way to pass data into the framework process. 
  For WS-Security panels, this is used to convey the key and trust store 
  information.
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.concepts.mustunderstand"></a>1.4.&nbsp;Must Understand</h3></div></div></div><p>
  WS-Security headers support a 
  <code class="sgmltag-attribute">mustUnderstand</code>
  attribute. If this attribute is set to "<code class="sgmltag-attvalue">1</code>", 
  it means all intermediaries must be able to process the security information.
  If a signature is included, the intermediaries must be able to verify it. 
  If intermediaries are not required to process the security token, 
  then this attribute should have a value of "<code class="sgmltag-attvalue">0</code>" 
  or the attribute must be absent 
  (zero is assumed when absent).
  </p><p>
  By default, a WS-Security binding configuration will add 
  <code class="code">mustUnderstand="1"</code>. 
  To override this default requires a custom property set on the binding. 
  This location for this custom property in the WAS admin console is 
  <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">General client policy set bindings</span> &rarr; <span class="guimenuitem">(binding)</span> &rarr; <span class="guimenuitem">WS-Security</span> &rarr; <span class="guimenuitem">Custom properties</span>.
  </p><p>
  The <span class="guilabel">mustUnderstand</span> custom property is defined under 
  <span class="guilabel">Outbound Custom Properties</span> 
  and is named 
  </p><pre class="programlisting">com.ibm.wsspi.wssecurity.config.request.setMustUnderstand</pre><p>
  </p><p>
  Another useful custom property for the client bindings is defined under 
  <span class="guilabel">Inbound Custom Properties</span>. 
  It determines whether the "consumer" requires a timestamp on the response. 
  Its name is
  </p><pre class="programlisting">com.ibm.wsspi.wssecurity.consumer.timestampRequired</pre><p>
  </p><p>
  Since this property is defined on the inbound section for a client, 
  it is referring to a response (from the provider). 
  By default this property value is 1; meaning the provider must sign sign a return 
  time stamp or the response will be rejected. 
  This restriction may be relaxed by setting this value to 0.
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.concepts.apps"></a>1.5.&nbsp;Application Code Requirements</h3></div></div></div><p>
  WS-Security policies can only be applied to Java bindings implemented with JAX-WS.
  They cannot be applied to JAX-RPC bindings.
  Services implemented with JAX-WS bindings will appear under 
  <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">Service providers</span>. 
  Service provides are always considered to be managed.
  </p><p>
  JAX-WS client bindings can be either managed or non-managed, 
  depending on how they are packaged and initialized. 
  
  A JAX-WS client is only managed if it is retrieved via a local JNDI reference. 
  Obtaining a JAX- WS service reference through either direct instantiation or
  through global JNDI look-up are not managed.
  Non-managed JAX-WS clients cannot have WS-Security policy applied to them
  because they bypass the required WAS runtime hooks.
  </p><p>
  Managed JAX-WS client have to be declared through either the
  <code class="code">@WebServiceRef</code> annotation or the 
  <code class="sgmltag-element">service-ref</code> 
  entry in a deployment descriptor.
  The <code class="code">@WebServiceRef</code> annotation is the more convenient option. 
  But scanning for this annotation is restricted to EJB classes, Servlet classes, 
  JAX-WS handler classes, and some service endpoint implementations. 
  Moreover, it is not always practical to add <code class="code">@WebServiceRef</code>
  annotations to every class in which a service client is required.
  </p><p>
  Web application projects can have a 
  <code class="sgmltag-element">service-ref</code>
  element to their <code class="filename">web.xml</code> deployment descriptor.
  The following is how such an entry would look for the CC example consumer 
  web application.
  </p><pre class="programlisting">
 &lt;service-ref&gt;
   &lt;service-ref-name&gt;service/CCService&lt;/service-ref-name&gt;
   &lt;service-interface&gt;org.acme.cc.jaxws.CCService&lt;/service-interface&gt;
 &lt;/service-ref&gt;</pre><p>
  This works when the JAX-WS client binding classes are packaged within 
  the WAR project, either directly compiled to the classes directory or
  included as a JAR file in 
  <code class="filename">WEB-INF/lib</code>. 
  But if the JAX-WS client bindings are packaged as a utility JAR included 
  within the EAR file, an extra element is needed in the deployment descriptor.
  </p><pre class="programlisting">
 &lt;service-ref&gt;
   &lt;service-ref-name&gt;service/CCService&lt;/service-ref-name&gt;
   &lt;service-interface&gt;org.acme.cc.jaxws.CCService&lt;/service-interface&gt;
   &lt;service-qname xmlns:pfx="urn:issw:bare:wssec:cc:query"&gt;pfx:CCService&lt;/service-qname&gt;
 &lt;/service-ref&gt;</pre><p>
  The <code class="sgmltag-element">service-qname</code> element allows the local
  reference look-up to successfully determine the QName for the client
  binding service class. The <code class="code">xmlns:pfx</code> attribute is a 
  namespace declaration. The value should be the namespace declared for 
  your service element of the relevant WSDL document.
  </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.chap.body"></a>2.&nbsp;Implementation</h2></div></div></div><p>
  The signatures described here are considered protection tokens 
  for the purpose of configuration within the WAS admin console. In our 
  app-to-app scenario, the signature is doubling as an authentication 
  mechanism of sorts, since only the possessor of the private key could have 
  signed the message. But don't let this secondary usage misguide you when 
  working through the policy set binding panels. The signature scenario 
  exclusively deals with protection tokens, not authentication tokens.
  </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.signts.keystores"></a>2.1.&nbsp;Key Stores</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec.signts.keystores.consumer"></a>2.1.1.&nbsp;Service Consumer</h4></div></div></div><p>
  The service consumer requires a key store containing a private/public
  key pair that identifies the service consumer application. The public 
  key will be extracted so that it may be provided to the consumer for 
  the purpose establishing trust.
  </p><p>
  This key store, key alias, and password will be configured in the general 
  client policy bindings as a reference to a managed key store. The scripting 
  burden of the WS-Security configuration would be eased if the key store and 
  key alias names could be consistent among environments.
  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec.signts.keystores.provider"></a>2.1.2.&nbsp;Service Provider</h4></div></div></div><p>
  The service provider requires a trust store containing the signer certificates 
  that the provider is willing to accept.
  For this WS-Security configuration, this amounts to the CCConsumer public certificate.
  </p><p>
  As with the service consumer case, choosing a consistent name for trust store 
  simplifies the scripting of the service provider policy set bindings.
  </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.signts.policyset"></a>2.2.&nbsp;The Policy Set</h3></div></div></div><p>
A policy set is a set of WS-Policy documents. 
As mentioned in <a class="xref" href="#sec.concepts.whatandhow" title="1.1.&nbsp;What versus How">Section&nbsp;1.1</a>, 
a policy document addresses what is to be done or enforced. 
Since both ends of a consumer-provider channel must agree on this, 
the policy document is usually shared between both parties.
</p><p>
In the present case, the policy document will specify the signing 
of a time stamp. Later sections address policy set bindings that 
configure role and environment specific configurations, 
mostly to do with key stores.
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec.signts.policyset.create"></a>2.2.1.&nbsp;Policy Set Creation</h4></div></div></div><p>
  The following steps show how to create a policy set that specifies
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      A timestamp to be added to the WS-Security header
    </li><li class="listitem">
      the timestamp to be signed
    </li></ul></div><p>
  This policy set is simple enough to create from scratch.
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
    In the WAS admin console, navigate to
    <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">Policy sets</span> &rarr; <span class="guimenuitem">Application Policy sets</span>.
    </p></li><li class="step"><p>
    Click the <span class="guibutton">New</span> button.
    </p></li><li class="step"><p>
    For <span class="guilabel">Name</span>, enter <code class="literal">Sign Timestamp</code>.
    </p></li><li class="step"><p>
    For <span class="guilabel">Description</span>, enter
    <code class="literal">Add a timestamp to the SOAP security header and sign it.</code>
    </p></li><li class="step"><p>
    In the <span class="guilabel">Policies</span> section,
    click the <span class="guibutton">New</span> button
    and select <span class="guimenuitem">WS-Security</span>.
    This will cause a <span class="guilabel">WS-Security</span> link to appear in the list.
    </p></li><li class="step"><p>Click the <span class="guilabel">WS-Security</span> link.</p></li><li class="step"><p>
    Click the <span class="guilabel">main policy</span> link.
    </p><p>
    This panel holds all settings for the WS-Security policy.  The
    <span class="guilabel">Message level protection</span> box should already be checked.
    In the present case, all we wish to do is add a timestamp and sign it.  We
    will remove the other items.
    </p><div class="figure"><a name="fig.signts.policy.main"></a><p class="title"><b>Figure&nbsp;1.&nbsp;Main Policy Panel</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="70%"><tr><td><img src="images/signtsPolicy01.png" width="100%" alt="Main Policy Panel"></td></tr></table></div></div></div><br class="figure-break"></li><li class="step"><p>
    The checkbox <span class="guilabel">Include timestamp in security header</span>
    should already be checked.
    </p></li><li class="step"><p>
    Click the <span class="guilabel">Request message part protection</span> link.
    </p></li><li class="step"><p>
    Under <span class="guilabel">Encrypted parts</span>,
    select <span class="guilabel">app_encparts</span> and click the
    <span class="guibutton">Delete</span>.
    We remove the encrypted parts because we will not be encrypting the
    payload at the message level.
    </p></li><li class="step"><p>
    Under <span class="guilabel">Signed parts</span>,
    select <span class="guilabel">app_signparts</span>
    and click <span class="guibutton">Edit</span>.
    </p><div class="figure"><a name="fig.signts.policy.signparts"></a><p class="title"><b>Figure&nbsp;2.&nbsp;Message parts to sign</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="70%"><tr><td><img src="images/signtsPolicy02.png" width="100%" alt="Message parts to sign"></td></tr></table></div></div></div><br class="figure-break"></li><li class="step"><p>
  By default there are five signed parts specified:
  three general parts and two timestamp parts at the bottom.
  Remove the top three parts compresed of the Body and two
  WS-Addressing QName parts.
  You should be left with two XPath expression parts for the timestamp:
  one for SOAP 1.1 and one for SOAP 1.2.
  </p></li><li class="step"><p>
  Click <span class="guibutton">OK</span> for the signed parts and
  <span class="guibutton">Done</span> for the request message part protection.
  </p></li><li class="step"><p>
  Click <span class="guilabel">Asymmetric signature and encryption policies</span>.
  Verify that <span class="guilabel">X.509</span> is chosen for the
  Message Integrity Policy
  section as shown in <a class="xref" href="#fig.signts.policy.sigpolicies" title="Figure&nbsp;3.&nbsp;Asymmetric signature and encryption policies">Figure&nbsp;3</a>.
  </p><div class="figure"><a name="fig.signts.policy.sigpolicies"></a><p class="title"><b>Figure&nbsp;3.&nbsp;Asymmetric signature and encryption policies</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="70%"><tr><td><img src="images/signtsPolicy03.png" width="100%" alt="Asymmetric signature and encryption policies"></td></tr></table></div></div></div><br class="figure-break"><p>
  If they are not present, click the <span class="guibutton">Action</span> drop-down
  menu and select <span class="guimenuitem">Add X.509 Type</span>.
  Choose the version shown in <a class="xref" href="#fig.signts.policy.x509type" title="Figure&nbsp;4.&nbsp;Add X.509 Type">Figure&nbsp;4</a>.
  </p><div class="figure"><a name="fig.signts.policy.x509type"></a><p class="title"><b>Figure&nbsp;4.&nbsp;Add X.509 Type</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="30%"><tr><td><img src="images/signtsPolicy04.png" width="100%" alt="Add X.509 Type"></td></tr></table></div></div></div><br class="figure-break"></li></ol></div><p>
This completes the specification of the request message protection.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
  The default algorithms are fine; but may be adjusted.
  If you choose this section, only adjust the
  <span class="guilabel">Algorithm suite</span>.
  Do not change the <span class="guilabel">Canonicalization algorithm</span>
  or the <span class="guilabel">XPath version</span> unless you know what
  you're doing.
  </p></li><li class="listitem"><p>
  There are no request or response tokens for this configuration.
  </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec.signts.policyset.importexport"></a>2.2.2.&nbsp;Policy Set Export and Import</h4></div></div></div><p>
  A policy set is usually shared between consumer and provider instances
  as well as among different environments.
  It is usually created once and exported; 
  then imported wherever else it is needed.
  </p><p>
  To export the <code class="classname">Sign Timestamp</code> policy, navigate to
  <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">Policy sets</span> &rarr; <span class="guimenuitem">Application policy sets</span>.
  Check the box next to <span class="guilabel">Sign Timestamp</span> and click the
  <span class="guibutton">Export</span> button at the top.  This will reveal a
  <span class="guilabel">Sign Timestamp.zip</span> link.  Click this link to
  download the policy set export.
  </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td valign="top" align="center" rowspan="2" width="25"><img alt="[Tip]" src="images/tip.png"></td><th align="left">Tip</th></tr><tr><td valign="top" align="left"><p>
  Because "Sign Timestamp" contains a space in the name for readability,
  the admin console will supply a default file name of
  <code class="filename">Sign Timestamp.zip</code>.
  Scripting will be simplified if this space is removed from the file name.
  This space will still be preserved for the policy name after import into
  other WAS cells.
  </p></td></tr></table></div><p>
  Here are the steps to import a policy set.
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
  In the admin console, navigate to 
  <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">Policy sets</span> &rarr; <span class="guimenuitem">Application policy sets</span>.
  </p></li><li class="step"><p>
  Click the <span class="guibutton">Import</span> button and select
  <span class="guilabel">From Selected location</span>.
  </p></li><li class="step"><p>
  Click the <span class="guibutton">Browse</span> button and select the
  policy set archive.
  </p></li><li class="step"><p>
  Click <span class="guibutton">OK</span>.
  </p></li></ol></div><p>
  </p><p>
  The imported policy set should now appear in the list of
  application policy sets.
  </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec.signts.clientbindings"></a>2.3.&nbsp;Client Policy Set Bindings</h3></div></div></div><p>
The client policy set bindings for the CCConsumerApp application
specifies how the consumer application will sign the SOAP payload
elements required by the policy set.  This amounts to specifying
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
a key store along with the alias of the key used to sign the request,
</li><li class="listitem">
how the corresponding certificate is to be identified.
</li></ul></div><p>
These concepts are illustrated below in 
<a class="xref" href="#fig.signts.clientbindings.concepts" title="Figure&nbsp;5.&nbsp;Client binding concepts">Figure&nbsp;5</a>
as objects in a WAS configuration.
</p><div class="figure"><a name="fig.signts.clientbindings.concepts"></a><p class="title"><b>Figure&nbsp;5.&nbsp;Client binding concepts</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="70%"><tr><td><img src="images/clientBindingsConcepts.jpg" width="100%" alt="Client binding concepts"></td></tr></table></div></div></div><br class="figure-break"><p>
The <em class="firstterm">protection token</em> object references a key store and
contains properties for specifying the alias of the relevant key in the key
store along with a key store password.
It represents a private key in the configuration.
</p><p>
The <em class="firstterm">key info</em> object determines how information about
the key will be added to the payload.  Examples include referring to the
certificate's serial number, the certificate's SHA1 thumbprint, or just
including the entire certificate as base64-encoded text.
In addition to specifying how the key will be referenced in the payload, 
it also includes a reference to the key itself through through a reference 
to the associated protection token object.
</p><p>
The <em class="firstterm">request message protection</em> object binds the 
protection token and key info into a single configuration.
Only when key info objects are referenced by a request message protection
object are they "activated" by the binding.
</p><p>
The objects in <a class="xref" href="#fig.signts.clientbindings.concepts" title="Figure&nbsp;5.&nbsp;Client binding concepts">Figure&nbsp;5</a> are
configured in the WAS admin console by navigating to
  <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">Policy sets</span> &rarr; <span class="guimenuitem">General client policy set bindings</span>.
  After selecting from the particular binding, click the
  <span class="guimenu">WS-Security</span> link.
  unfortunately not all objects are available from the same panel.
  <a class="xref" href="#fig.signts.clientbindings.overlay" title="Figure&nbsp;6.&nbsp;Client binding concepts overlayed on screen shot">Figure&nbsp;6</a> gathers together
  the three screens needed for this configuration with the conceptual
  objects from <a class="xref" href="#fig.signts.clientbindings.concepts" title="Figure&nbsp;5.&nbsp;Client binding concepts">Figure&nbsp;5</a>
  superimosed on them for reference.
</p><div class="figure"><a name="fig.signts.clientbindings.overlay"></a><p class="title"><b>Figure&nbsp;6.&nbsp;Client binding concepts overlayed on screen shot</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="70%"><tr><td><img src="images/clientBindingsOverlay.jpg" width="100%" alt="Client binding concepts overlayed on screen shot"></td></tr></table></div></div></div><br class="figure-break"><p>
  The WS-Security panel is shown at the top of
  <a class="xref" href="#fig.signts.clientbindings.overlay" title="Figure&nbsp;6.&nbsp;Client binding concepts overlayed on screen shot">Figure&nbsp;6</a>.
  The <span class="guilabel">Authentication and protection</span> link navigates to the
  panel on the left.
  The <span class="guilabel">Keys and certificates</span> link navigates to the panel
  on the right.
  The direction of the arrows in 
  <a class="xref" href="#fig.signts.clientbindings.overlay" title="Figure&nbsp;6.&nbsp;Client binding concepts overlayed on screen shot">Figure&nbsp;6</a>
  convey the direction of references.
  So the objects must be configured in the reverse order of the arrows so that
  the references may be resolved.
</p><div class="procedure"><ol class="procedure" type="1"><li class="step">Configure a managed key store as described in 
       <a class="xref" href="#sec.signts.keystores.consumer" title="2.1.1.&nbsp;Service Consumer">Section&nbsp;2.1.1</a>.
  </li><li class="step">Create a protection token object referencing the key store.</li><li class="step">Create a key info object referencing the protection token.</li><li class="step">Create a request message protection object referencing the key
    info object.
  </li><li class="step">Add custom properties.</li></ol></div><p>
  The panel for the last item is not shown in 
  <a class="xref" href="#fig.signts.clientbindings.overlay" title="Figure&nbsp;6.&nbsp;Client binding concepts overlayed on screen shot">Figure&nbsp;6</a>.
  But the <span class="guilabel">Custom properties</span> link to its panel is
  shown near the top.
</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec.signts.clientbindings.creation"></a>2.3.1.&nbsp;Creation</h4></div></div></div><p>
These instruction show how to create a client policy set binding from scratch
the supports the signing of a timestamp.
It presupposes the configuration of a managed key store named CCConsumerkeyStore
that holds the signer key and certificate.
The alias for the signer certificate is ccconsumer.
</p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
    In the Admin Console navigate to
    <span class="guimenu">Services</span> &rarr; <span class="guimenuitem">Policy sets</span> &rarr; <span class="guimenuitem">General client policy set bindings</span>.
  </p></li><li class="step"><p>Click the <span class="guibutton">New</span> button.</p></li><li class="step"><p>
    For <span class="guilabel">Bindings configuration name</span>, enter
    <code class="literal">CCConsumerBindings</code>.
  </p></li><li class="step"><p>
    For <span class="guilabel">Description</span>, enter
    <code class="literal">Specify key and key info to generate a signature for a timestamp</code>.
  </p></li><li class="step"><p>
    In the empty list of policies, click the <span class="guibutton">Add</span> button and select
    <span class="guilabel">WS-Security</span> from the dropdown list.
    </p><p>
    This reveals the four sections for the message security policy bindings.  This will
    be the starting point for much of the binding configuration and will henceforth be
    referred to as the <em class="firstterm">bindings list of four</em>.
  </p></li><li class="step"><p>
    Select the <span class="guilabel">Authentication and protection</span> link from the
    bindings list of four.
  </p></li><li class="step"><p>
    Under <span class="guilabel">Protection tokens</span> click the <span class="guibutton">New token</span>
    button and select <span class="guilabel">Token generator</span>.  The client is a token generator
    (instead of consumer) because the client provides the signature of the timestamp.
  </p></li><li class="step"><p>
    For <span class="guilabel">Name</span>, enter <code class="literal">gen_signx509token</code>.
    </p><p>
    This name can be arbitrary.  For this scenario, we stick to the convention used by the
    sample bindings included with WAS.  The "<code class="literal">gen</code>" portion of the name
    refers to its role as a token generator ("<code class="literal">con</code>" for consumer is an
    alternative).  The "<code class="literal">sign</code>" portion designates the role of a signatue
    signer ("<code class="literal">enc</code>" for encryption is the alternative).
  </p></li><li class="step"><p>
    For <span class="guilabel">Token type</span>, select <span class="guilabel">X509V3 v1.0</span>.
  </p></li><li class="step"><p>
    Click the <span class="guibutton">OK</span> button.
    This adds the entry to the list of protection tokens.
    But it still requies additional configuration.
    So click the <span class="guilabel">gen_signx509token</span> link under protection tokens.
  </p></li><li class="step"><p>
    Near the bottom under <span class="guilabel">Additional Bindings</span>,
    click the <span class="guilabel">Callback handler</span> link.
  </p></li><li class="step"><p>
    Under the <span class="guilabel">Keystore</span> section,
    choose the <span class="guilabel">CCConsumerKeyStore</span> managed key store created earlier.
    Since it should only have a single key pair, the <span class="guilabel">Name</span> and
    <span class="guilabel">Alias</span> are populated automatically.
    You must still provide the password.
  </p></li><li class="step"><p>
    Click <span class="guibutton">OK</span> twice and <span class="guilabel">save</span> the configuration.
    </p><p>
    At this point, your binding configuration ha sspecified the key to use for the signature
    (the policy set determined what to sign).
    When the service provider receives the signature, it needs a way to determine what
    certificate to use for verification.
    This information is called the <em class="firstterm">key info</em> and there are several
    standards-based ways to specify it.
    We specify the embedded token option in the next steps.
  </p></li><li class="step"><p>
    Navigate back to the <span class="guilabel">General client policy set bindings</span> panel of
    Step 1.
    You should see the new <span class="guilabel">CCConsumerBindings</span> entry.
  </p></li><li class="step"><p>
    Click <span class="guilabel">Keys and certificates</span>.
  </p></li><li class="step"><p>
    Under the <span class="guilabel">Key information</span> section, click <span class="guilabel">New Outbound</span>.
    We choose outbound because the signature will be outbound from the consumer.
  </p></li><li class="step"><p>
    For <span class="guilabel">Name</span>, enter <code class="literal">gen_signkeyinfo</code>.
  </p></li><li class="step"><p>
    For <span class="guilabel">Type</span>, select <span class="guilabel">Embedded token</span> from the dropdown list.
  </p></li><li class="step"><p>
    For <span class="guilabel">Token generator or consumer name</span>, 
    choose the <span class="guilabel">gen_signx509token</span> key entry created in the previous section.
    </p><p>
    Since we are developing this binding from scratch, it should be the only entry available.
    If instead we had copied a sample binding to modify, there would be many entries available
    and we must take care to choose the right one.
  </p></li><li class="step"><p>
    Click <span class="guibutton">OK</span> and <span class="guilabel">save</span>.
    </p><p>
    At this point you have specified a key for signing the timestamp and specified how the key
    identity is to be conveyed.
  </p></li><li class="step"><p>
    Navigate back to the binding list of four (click <span class="guilabel">WS-Security</span> in the
    bread-crumb tail at the top) and select <span class="guilabel">Authentication and protection</span>.
    </p><p>
    You'll see the key definition we created earlier under <span class="guilabel">Protection tokens</span>.
    It references a particular key in a key store.  This protection token was itself referenced
    in the previous section by a key info object (Step 19).  
    These definitions by themselves do activate them.
    To be active, they must be referenced by either a request or response message protection object.
  </p></li><li class="step"><p>
    Under <span class="guilabel">Request message signature and encryption protection</span>,
    click the <span class="guibutton">New Signature</span> button.
  </p></li><li class="step"><p>
    For <span class="guilabel">Name</span>, enter <code class="literal">asymmetric-signingInfoRequest</code>.
  </p></li><li class="step"><p>
    For <span class="guilabel">Signing key information</span>, choose <span class="guilabel">gen_signkeyinfo</span>
    from the dropdown list.
    This was the key info we created earlier and should be the only choice available.
  </p></li><li class="step"><p>
    Click the link labeled <span class="guilabel">Signed part reference default</span>.
  </p></li><li class="step"><p>
    In the <span class="guilabel">URL</span> field, select
    <span class="guilabel">http://www.w3.org/2001/10/xml-exc-c14n#</span>.
  </p></li><li class="step"><p>
    Click <span class="guibutton">OK</span> and <span class="guilabel">save</span>.
  </p></li><li class="step"><p>
    Navigate back to the bindings list of four and select <span class="guilabel">Custom properties</span>.
    We use two custom properties to specify that not all intermediaries are required to understand
    the signatures and that the client does not require a signed timestamp on the response.
  </p></li><li class="step"><p>
    Under <span class="guilabel">Inbound Custom Properties</span>, 
    set the following property to <code class="literal">0</code>:
    </p><p>
    <code class="literal">com.ibm.wsspi.wssecurity.consumer.timestampRequired</code>
  </p></li><li class="step"><p>
    Under the <span class="guilabel">Outbound Custom Properties</span>,
    set the following property to <code class="literal">0</code>:
    </p><p>
    <code class="literal">com.ibm.wsspi.wssecurity.config.request.setMustUnderstand</code>
  </p><div class="figure"><a name="fig.signts.clientbindings.customprops"></a><p class="title"><b>Figure&nbsp;7.&nbsp;Client binding concepts overlayed on screen shot</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" style="cellpadding: 0; cellspacing: 0;" width="70%"><tr><td><img src="images/clientBindingsCustomProperties.png" width="100%" alt="Client binding concepts overlayed on screen shot"></td></tr></table></div></div></div><br class="figure-break"></li><li class="step"><p>
    Click <span class="guibutton">OK</span> and <span class="guilabel">save</span>.
  </p></li></ol></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec.signts.clientbindings.export"></a>2.3.2.&nbsp;Export and Import</h4></div></div></div><p>
  Exporting a client bindings is useful for backup and scripting.
  It is not typically shared with other client systems since policy set bindings are
  particular to their environment.
  In the present case, a managd key store is the only external reference.
  The external reference requires the following three items.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">the name of the managed key store</li><li class="listitem">the password for the managed key store</li><li class="listitem">the alias of the signer key</li></ul></div><p>
  Importing a client binding configuration will require that these match with an existing
  key store of that these items be adusted to an existing key store.
</p><p>
  To export a client binding configuration, simply check the box next to its entry and
  click the <span class="guibutton">Export</span> button.
  A link will be provided for starting the download.
</p></div></div></div></div></body></html>